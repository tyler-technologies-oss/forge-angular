// This code was generated by the angular-custom-elements-schematic.  Any changes will be overwritten next time it runs.
import { booleanAttribute, Component, ElementRef, ChangeDetectionStrategy, ChangeDetectorRef, NgZone, numberAttribute, Input } from '@angular/core';
import { OverlayComponent as OverlayComponentCustomElement, defineOverlayComponent } from '@tylertech/forge';

/**  */
@Component({
  selector: 'forge-overlay',
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: '<ng-content></ng-content>'
})
export class OverlayComponent {

	/** The forge-overlay element. */
	public readonly nativeElement = this.elementRef.nativeElement;

	/** The element to use as the arrow for the overlay. */
	@Input()
	public set arrowElement(value: OverlayComponentCustomElement['arrowElement']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.arrowElement = value;
		});
	}
	public get arrowElement(): OverlayComponentCustomElement['arrowElement'] {
		return this.nativeElement.arrowElement;
	}

	/** The offset to apply to the arrow element. */
	@Input({ transform: numberAttribute })
	public set arrowElementOffset(value: OverlayComponentCustomElement['arrowElementOffset']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.arrowElementOffset = value;
		});
	}
	public get arrowElementOffset(): OverlayComponentCustomElement['arrowElementOffset'] {
		return this.nativeElement.arrowElementOffset;
	}

	/** Whether or not the overlay is open. */
	@Input({ transform: booleanAttribute })
	public set open(value: OverlayComponentCustomElement['open']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.open = value;
		});
	}
	public get open(): OverlayComponentCustomElement['open'] {
		return this.nativeElement.open;
	}

	/** Whether or not the overlay should be rendered inline (not in the :top-layer). */
	@Input({ transform: booleanAttribute })
	public set inline(value: OverlayComponentCustomElement['inline']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.inline = value;
		});
	}
	public get inline(): OverlayComponentCustomElement['inline'] {
		return this.nativeElement.inline;
	}

	/** The element to anchor the overlay to. */
	@Input()
	public set anchorElement(value: OverlayComponentCustomElement['anchorElement']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.anchorElement = value;
		});
	}
	public get anchorElement(): OverlayComponentCustomElement['anchorElement'] {
		return this.nativeElement.anchorElement;
	}

	/** The id of the element to anchor the overlay to. */
	@Input()
	public set anchor(value: OverlayComponentCustomElement['anchor']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.anchor = value;
		});
	}
	public get anchor(): OverlayComponentCustomElement['anchor'] {
		return this.nativeElement.anchor;
	}

	/** Whether or not the overlay should be rendered without an anchor (centered on page by default). */
	@Input({ transform: booleanAttribute })
	public set noAnchor(value: OverlayComponentCustomElement['noAnchor']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.noAnchor = value;
		});
	}
	public get noAnchor(): OverlayComponentCustomElement['noAnchor'] {
		return this.nativeElement.noAnchor;
	}

	/** The placement of the overlay relative to the anchor element. */
	@Input()
	public set placement(value: OverlayComponentCustomElement['placement']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.placement = value;
		});
	}
	public get placement(): OverlayComponentCustomElement['placement'] {
		return this.nativeElement.placement;
	}

	/** The positioning strategy to use for the overlay. Valid values are `'fixed'` and `'absolute'`. */
	@Input()
	public set positionStrategy(value: OverlayComponentCustomElement['positionStrategy']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.positionStrategy = value;
		});
	}
	public get positionStrategy(): OverlayComponentCustomElement['positionStrategy'] {
		return this.nativeElement.positionStrategy;
	}

	/** The offset to apply to the overlay position relative to the anchor element. */
	@Input()
	public set offset(value: OverlayComponentCustomElement['offset']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.offset = value;
		});
	}
	public get offset(): OverlayComponentCustomElement['offset'] {
		return this.nativeElement.offset;
	}

	/** Whether or not the anchor element should shift along the side of the overlay when scrolling. */
	@Input({ transform: booleanAttribute })
	public set shift(value: OverlayComponentCustomElement['shift']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.shift = value;
		});
	}
	public get shift(): OverlayComponentCustomElement['shift'] {
		return this.nativeElement.shift;
	}

	/** Whether or not the overlay should hide itself when the anchor element is out of view. */
	@Input()
	public set hide(value: OverlayComponentCustomElement['hide']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.hide = value;
		});
	}
	public get hide(): OverlayComponentCustomElement['hide'] {
		return this.nativeElement.hide;
	}

	/** Whether or not the overlay handles light dismiss itself or not. */
	@Input({ transform: booleanAttribute })
	public set persistent(value: OverlayComponentCustomElement['persistent']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.persistent = value;
		});
	}
	public get persistent(): OverlayComponentCustomElement['persistent'] {
		return this.nativeElement.persistent;
	}

	/** Whether or not the overlay should flip to the opposite placement when not enough room. */
	@Input()
	public set flip(value: OverlayComponentCustomElement['flip']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.flip = value;
		});
	}
	public get flip(): OverlayComponentCustomElement['flip'] {
		return this.nativeElement.flip;
	}

	/** The id of the element to use as the boundary for the overlay. */
	@Input()
	public set boundary(value: OverlayComponentCustomElement['boundary']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.boundary = value;
		});
	}
	public get boundary(): OverlayComponentCustomElement['boundary'] {
		return this.nativeElement.boundary;
	}

	/** The element to use as the boundary for the overlay. */
	@Input()
	public set boundaryElement(value: OverlayComponentCustomElement['boundaryElement']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.boundaryElement = value;
		});
	}
	public get boundaryElement(): OverlayComponentCustomElement['boundaryElement'] {
		return this.nativeElement.boundaryElement;
	}

	/** The fallback placements to use when the overlay cannot be placed in the desired placement. */
	@Input()
	public set fallbackPlacements(value: OverlayComponentCustomElement['fallbackPlacements']) {
		this.zone.runOutsideAngular(() => {
			this.nativeElement.fallbackPlacements = value;
		});
	}
	public get fallbackPlacements(): OverlayComponentCustomElement['fallbackPlacements'] {
		return this.nativeElement.fallbackPlacements;
	}


	public position(...args: Parameters<OverlayComponentCustomElement['position']>): ReturnType<OverlayComponentCustomElement['position']> {
		return this.zone.runOutsideAngular(() => this.nativeElement.position(...args));
	}

	constructor(
		changeDetectorRef: ChangeDetectorRef,
		protected elementRef: ElementRef<OverlayComponentCustomElement>,
		protected zone: NgZone
	) {
		defineOverlayComponent();
		changeDetectorRef.detach();
	}
}
